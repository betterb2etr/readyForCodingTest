# 그리디 알고리즘(탐욕법)

그리디 알고리즘(탐욕법)은 크게 이런 특징을 가집니다.

현재만 보고 “지금 최선”을 고른다

매 단계에서 전체 미래를 다 따져보지 않고, 그 시점에서 가장 좋아 보이는 선택을 합니다.

예: 동전 거스름돈에서 항상 가장 큰 동전부터 쓰기.

한 번 한 선택은 되돌리지 않는다

“이 선택이 나중에 마음에 안 들면 바꾸자”가 아니라, 한 번 고른 건 그대로 밀고 갑니다.

그래서 구현이 단순하고 빠르지만, 항상 정답을 보장하진 않습니다.

부분 최적이 전체 최적이 되는 구조에서 잘 통한다

“탐욕 선택 속성(Greedy choice property)”와 “최적 부분 구조(Optimal substructure)”를 만족하는 문제에서만 진짜 최적해를 보장합니다.

쉽게 말하면, 각 단계의 최선 선택들이 모여서 전체적으로도 최선이 되는 문제들입니다.

완전탐색·DP보다 구현이 간단하고 빠르다

정렬, 우선순위 큐(힙) 같은 자료구조와 자주 같이 쓰입니다.

반대로, 반례가 쉽게 나오는 문제라면 DP나 완전탐색이 필요합니다.

지금까지 푼 “예산”, “최솟값 만들기” 같은 문제들은 “작은 것부터 / 큰 것부터” 순서대로 고르는 전략이 전체에서도 최적이라서 전형적인 그리디 문제에 속합니다.


### sort
sort(A.begin(),A.end());
sort(A.begin(),A.end(),greater<int>());

### caculation
for(int x: A)
or
for(int i=0;i<A.size();i++)